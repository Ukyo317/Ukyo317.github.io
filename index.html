<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Ukyo Chen&#39;s blogs">
<meta property="og:url" content="https://ukyo317.github.io/index.html">
<meta property="og:site_name" content="Ukyo Chen&#39;s blogs">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ukyo Chen&#39;s blogs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ukyo317.github.io/">





  <title>Ukyo Chen's blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ukyo Chen's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/JVM/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>线程私有<br>字节码</p>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h3><p>栈帧<br>栈内存，局部变量表<br>异常</p>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>Native方法</p>
<h3 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4. Java堆"></a>4. Java堆</h3><p>线程共享<br>最大内存<br>对象实例和数组<br>GC堆<br>逻辑连续</p>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>线程共享<br>复杂</p>
<h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h3><h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h3><h1 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h1><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>字节码 –&gt; 方法区</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>文件格式验证</p>
<p>Class文件格式规范</p>
<p>元数据验证</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/Flask/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/Flask/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="flask底层实现多进程"><a href="#flask底层实现多进程" class="headerlink" title="flask底层实现多进程"></a>flask底层实现多进程</h2><p>flask应用程序示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/index")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"index test,sleep for 15 second"</span>)</span><br><span class="line">    time.sleep(<span class="number">15</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"index test for non-block"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(__name__)</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">8088</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">8088</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>当我们在浏览器种访问<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A8088/index" target="_blank" rel="noopener">http://127.0.0.1:8088/index</a>的时候，系统会被time.sleep(15)阻塞15秒才能够得到返回，而当在这15秒内我们再次访问<a href="https://link.zhihu.com/?target=http%3A//127.0.0.1%3A8088" target="_blank" rel="noopener">http://127.0.0.1:8088</a>访问另外一个路由的时候，”hello world”会立刻返回，说明<u>该请求未被前一个请求阻塞</u>。现在，我们尝试对<strong>app.run()</strong>之后发生的事情做一个分析。</p>
<p>源码分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run()函数位于flask/app.py中的Flask类下，核心代码如下：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, host=None, port=None, debug=None, load_dotenv=True, **options)</span>:</span></span><br><span class="line">        <span class="string">"""省略部分代码"""</span></span><br><span class="line">        _host = <span class="string">"127.0.0.1"</span></span><br><span class="line">        _port = <span class="number">5000</span></span><br><span class="line">        server_name = self.config.get(<span class="string">"SERVER_NAME"</span>)</span><br><span class="line">        sn_host, sn_port = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> server_name:</span><br><span class="line">            sn_host, _, sn_port = server_name.partition(<span class="string">":"</span>)</span><br><span class="line"></span><br><span class="line">        host = host <span class="keyword">or</span> sn_host <span class="keyword">or</span> _host</span><br><span class="line">        <span class="comment"># pick the first value that's not None (0 is allowed)</span></span><br><span class="line">        port = int(next((p <span class="keyword">for</span> p <span class="keyword">in</span> (port, sn_port) <span class="keyword">if</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>), _port))</span><br><span class="line"></span><br><span class="line">        options.setdefault(<span class="string">"use_reloader"</span>, self.debug)</span><br><span class="line">        options.setdefault(<span class="string">"use_debugger"</span>, self.debug)</span><br><span class="line">        options.setdefault(<span class="string">"threaded"</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        cli.show_server_banner(self.env, self.debug, self.name, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> werkzeug.serving <span class="keyword">import</span> run_simple</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            run_simple(host, port, self, **options)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># reset the first request information if the development server</span></span><br><span class="line">            <span class="comment"># reset normally.  This makes it possible to restart the server</span></span><br><span class="line">            <span class="comment"># without reloader and that stuff from an interactive shell.</span></span><br><span class="line">            self._got_first_request = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>在run函数内，函数设置了服务启动的address，port等信息，最后引入了一个werkzeug库的run_simple方法，另外还传入了一个options参数。    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run_simple(host, port, self, **options)</span><br></pre></td></tr></table></figure>

<p>要特别注意的是，options.setdefault(“threaded”,True)这行代码在最初的flask 0.1系列版本种是不存在的。</p>
<p><img src="https://pic4.zhimg.com/v2-65d4e185b9a93768a874742e418cc10b.jpg" alt="img"></p>
<p>以上是flask 0.12版本种的代码，这也就也为这通过传入threaded=false的方式可以使得flask以单进程单线程的阻塞方式运行，这样当前一个请求被阻塞，之后的请求也将被阻塞。</p>
<p>我们再进入到werkzeug中去看看run_simple()中发生了什么事情，关键代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该文件位于werkzeug库中的server.py文件中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_simple</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    hostname,</span></span></span><br><span class="line"><span class="function"><span class="params">    port,</span></span></span><br><span class="line"><span class="function"><span class="params">    application,</span></span></span><br><span class="line"><span class="function"><span class="params">    use_reloader=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    use_debugger=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    use_evalex=True,</span></span></span><br><span class="line"><span class="function"><span class="params">    extra_files=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    reloader_interval=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    reloader_type=<span class="string">"auto"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    threaded=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    processes=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    request_handler=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    static_files=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    passthrough_errors=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    ssl_context=None,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>:</span></span><br><span class="line">   <span class="string">"省略部分代码"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fd = int(os.environ[<span class="string">"WERKZEUG_SERVER_FD"</span>])</span><br><span class="line">        <span class="keyword">except</span> (LookupError, ValueError):</span><br><span class="line">            fd = <span class="literal">None</span></span><br><span class="line">        srv = make_server(</span><br><span class="line">            hostname,</span><br><span class="line">            port,</span><br><span class="line">            application,</span><br><span class="line">            threaded,</span><br><span class="line">            processes,</span><br><span class="line">            request_handler,</span><br><span class="line">            passthrough_errors,</span><br><span class="line">            ssl_context,</span><br><span class="line">            fd=fd,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> fd <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            log_startup(srv.socket)</span><br><span class="line">        srv.serve_forever()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> use_reloader:</span><br><span class="line">        <span class="string">"省略部分代码"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inner()</span><br></pre></td></tr></table></figure>

<p>flask框架是通过调用Werkzeug这个第三方库来创建web服务，监听用户的请求，要了解Werkzeug首先我们需要去知道python的WSGI协议。</p>
<h3 id="WSGI协议"><a href="#WSGI协议" class="headerlink" title="WSGI协议"></a>WSGI协议</h3><p>reference:<br><a href="https://zhuanlan.zhihu.com/p/68676316" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68676316</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>,<span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(stataus, response_headers)</span><br><span class="line">    <span class="keyword">return</span>[<span class="string">'Hello World'</span>]</span><br></pre></td></tr></table></figure>

<p>WSGI 对于 application 对象有如下三点要求</p>
<ul>
<li>必须是一个可调用的对象</li>
<li>接收两个必选参数environ、start_response</li>
<li>返回值必须是可迭代对象，用来表示http body</li>
</ul>
<p>这种规范格式约定：web服务器比如Werkzeug调用应用提供的某个函数application()向这个函数传入environ,start_reponse这两个参数，最终该应用的这个函数返回一个可迭代对象给web服务器。</p>
<p><img src="https://pic4.zhimg.com/v2-562b1e291ada982c40b930771ab22437.jpg" alt="img"></p>
<p>产品架构</p>
<p>用户管理，workflow，</p>
<p>医疗影像，业务相关，流程建模</p>
<p>hibernate</p>
<p>spring cloud</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/Algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/Algorithms/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>dfs</p>
<p>全排列问题<br>通用解法(for loop, 所有以subset开头的集合)，组合类问题专用(逐层决策)</p>
<p>全组合问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/高性能Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/高性能Mysql/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h1><p>MySQL最重要的特性是它的存储引擎架构：</p>
<p>这种架构将查询处理，及其他系统任务，和数据的存储/提取相分离。<br>这种处理和存储分离的设计可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式.</p>
<p><img src="C:%5CUsers%5Ccheny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1584197742897.png" alt="1584197742897"></p>
<p>最上层: 客户端</p>
<p>第二层: MySQL核心服务功能都在这一层<br>包括: 查询解析、分析、优化、缓存以及所有内置函数</p>
<p>第三层：存储引擎<br>负责MySQL中数据的存储和提取。<br>服务器通过API与存储引擎进行通信。<br>存储引擎不会解析SQL。</p>
<h1 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</span><br></pre></td></tr></table></figure>

<ul>
<li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li>
<li>你可以设定多个字段来排序。</li>
<li>你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。</li>
<li>你可以添加 WHERE…LIKE 子句来设置条件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from runoob_tbl ORDER BY submission_date DESC;</span><br></pre></td></tr></table></figure>

<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><ul>
<li>GROUP BY 语句根据一个或多个列对结果集进行分组。</li>
<li>在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name;</span><br></pre></td></tr></table></figure>

<p>使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;</span><br></pre></td></tr></table></figure>

<h3 id="使用-WITH-ROLLUP"><a href="#使用-WITH-ROLLUP" class="headerlink" title="使用 WITH ROLLUP"></a>使用 WITH ROLLUP</h3><p>WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。</p>
<p>例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;</span></span><br><span class="line">+--------+--------------+</span><br><span class="line">| name   | singin_count |</span><br><span class="line">+--------+--------------+</span><br><span class="line">| 小丽 |            2 |</span><br><span class="line">| 小明 |            7 |</span><br><span class="line">| 小王 |            7 |</span><br><span class="line">| NULL   |           16 |</span><br><span class="line">+--------+--------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>其中记录 NULL 表示所有人的登录次数。</p>
<p>我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select coalesce(a,b,c);</span><br></pre></td></tr></table></figure>

<p>参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。</p>
<p>以下实例中如果名字为空我们使用总数代替：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT coalesce(name, <span class="string">'总数'</span>), SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;</span></span><br><span class="line">+--------------------------+--------------+</span><br><span class="line">| coalesce(name, '总数') | singin_count |</span><br><span class="line">+--------------------------+--------------+</span><br><span class="line">| 小丽                   |            2 |</span><br><span class="line">| 小明                   |            7 |</span><br><span class="line">| 小王                   |            7 |</span><br><span class="line">| 总数                   |           16 |</span><br><span class="line">+--------------------------+--------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h2 id="主键和外键"><a href="#主键和外键" class="headerlink" title="主键和外键"></a>主键和外键</h2><p>Concepts:<br>reference: SQL的主键和外键的作用<br><a href="https://www.jianshu.com/p/394f8aa724f4" target="_blank" rel="noopener">https://www.jianshu.com/p/394f8aa724f4</a></p>
<p>概念，对比，示例</p>
<p>常用语句：<br>reference: MySQL添加/删除主键、外键、唯一键、索引、自增<br><a href="https://blog.csdn.net/u012643122/article/details/52890772" target="_blank" rel="noopener">https://blog.csdn.net/u012643122/article/details/52890772</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">--如果在表创建好了以后再加约束，则格式分别为</span><br><span class="line"></span><br><span class="line">--主键</span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">--&quot;PK&quot;为主键的缩写，字段名为要在其上创建主键的字段名，&quot;PK_字段名&quot;就为约束名</span><br><span class="line">ADD CONSTRAINT PK_字段名   </span><br><span class="line">--同上</span><br><span class="line">PRIMARY KEY(字段名)</span><br><span class="line"></span><br><span class="line">--唯一约束</span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">ADD CONSTRAINT UQ_字段名</span><br><span class="line">UNIQUE(字段名)</span><br><span class="line"># alter table tableName add primary key(id)</span><br><span class="line"></span><br><span class="line">--外键约束</span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">--&quot;FK&quot;为外键的缩写</span><br><span class="line">ADD CONSTRAINT FK_字段名</span><br><span class="line">FOREIGN KEY(字段名) REFERENCES 关联的表名(关联的字段名)</span><br><span class="line"></span><br><span class="line">--举个例子</span><br><span class="line">ALTER TABLE 表A</span><br><span class="line">ADD CONSTRAINT FK_B </span><br><span class="line">FOREIGN KEY(TicketNo) REFERENCES 表B(TicketNo)</span><br><span class="line"></span><br><span class="line">--级联更新，级联删除，这样在删除主表Student时，成绩表中该学生的所有成绩都会删除</span><br><span class="line">ALTER TABLE 成绩表 </span><br><span class="line">ADD CONSTRAINT FK_StudentNo </span><br><span class="line">FOREIGN KEY(StudentNo) REFERENCES Student(StudentNo)</span><br><span class="line">ON UPDATE CASCADE ON DELETE CASCADE</span><br><span class="line"></span><br><span class="line">--检查约束</span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">ADD CONSTRAINT CK_字段名</span><br><span class="line">--括号中的&quot;CK_字段名&gt;0&quot;为条件表达式，用关系运算符连接</span><br><span class="line">CHECK(字段名&gt;0)</span><br><span class="line"></span><br><span class="line">--默认值约束</span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">ADD CONSTRAINT DF_字段名</span><br><span class="line">--其中的&apos;默认值&apos;为想要设置的默认值，注意&apos;FOR&apos;</span><br><span class="line">DEFAULT &apos;默认值&apos; FOR 字段名</span><br><span class="line"></span><br><span class="line">--删除创建的约束</span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">--约束名为前面创建的如：FK_字段名这样的约束名</span><br><span class="line">DROP CONSTRAINT 约束名</span><br><span class="line">--注意：如果约束是在创建表的时候创建的，则不能用命令删除</span><br><span class="line">--只能在&apos;企业管理器&apos;里面删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--获取SqlServer中的表结构</span><br><span class="line">SELECT syscolumns.name,systypes.name,syscolumns.isnullable,syscolumns.length</span><br><span class="line">FROM syscolumns,systypes</span><br><span class="line">WHERE syscolumns.xusertype = systypes.xusertype</span><br><span class="line">AND syscolumns.id = OBJECT_ID(&apos;Student&apos;)</span><br><span class="line"></span><br><span class="line">--单独查询表递增字段</span><br><span class="line">SELECT [NAME] FROM syscolumns </span><br><span class="line">WHERE </span><br><span class="line">id = OBJECT_ID(N&apos;Student&apos;) AND COLUMNPROPERTY(id,name,&apos;IsIdentity&apos;)=1</span><br><span class="line"></span><br><span class="line">--获取表主外键约束</span><br><span class="line">EXEC sp_helpconstraint &apos;Student&apos;</span><br><span class="line"></span><br><span class="line">--查询表主键外键信息</span><br><span class="line">SELECT </span><br><span class="line">sysobjects.id AS objectId,</span><br><span class="line">OBJECT_NAME(sysobjects.parent_obj) AS TableName,</span><br><span class="line">sysobjects.name AS constraintName,</span><br><span class="line">sysobjects.xtype AS constraintType,</span><br><span class="line">syscolumns.name AS columnName</span><br><span class="line">FROM sysobjects INNER JOIN sysconstraints</span><br><span class="line">ON sysobjects.xtype IN(&apos;C&apos;,&apos;F&apos;,&apos;PK&apos;,&apos;UQ&apos;,&apos;D&apos;)</span><br><span class="line">AND sysobjects.id = sysconstraints.constid</span><br><span class="line">LEFT OUTER JOIN syscolumns ON sysconstraints.id = syscolumns.id</span><br><span class="line">WHERE OBJECT_NAME(sysobjects.parent_obj) = &apos;Student&apos;</span><br></pre></td></tr></table></figure>

<h1 id="创建高性能的索引"><a href="#创建高性能的索引" class="headerlink" title="创建高性能的索引"></a>创建高性能的索引</h1><h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><p>MySQL中，存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。</p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>存储引擎层，而非服务器层。所以类型很多，不同存储引擎中，即使类型相同，底层实现也可能不同。</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>B树：<br>1.叶子节点在同一层<br>2.每个节点关键字数：子树个数k - 1 (k: 介于树的阶M和它的1/2)<br>3.子树关键字：左小右大</p>
<p>索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序</p>
<p><strong>可以使用B-Tree索引的查询类型</strong>：<br><strong>全键值</strong>，<strong>键值范围</strong>或<strong>键前缀查找</strong></p>
<ul>
<li>全值匹配：和索引中所有列进行匹配</li>
<li>匹配最左前缀：只使用索引的第一列</li>
<li>匹配列前缀：只匹配某一列的值的开头部分</li>
<li>匹配范围值：匹配某一列值在某一范围内的部分</li>
<li>精确匹配某一列并范围匹配另一列</li>
<li><u>只访问索引的查询</u></li>
</ul>
<p><strong>限制（都和索引列的顺序有关）：</strong></p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引</li>
<li>不能跳过索引中的列</li>
<li>某个列范围查询，则右边的列无法使用索引优化查询</li>
</ul>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>基本概念</p>
<ul>
<li><strong>精确</strong>匹配<strong>所有列的查询</strong>才有效。</li>
<li>哈希索引会将所有的<strong>哈希码</strong>存储在索引中，同时在哈希表中保存<strong>指向每个数据行的指针</strong>。</li>
<li>只有Memory引擎显式支持哈希索引。</li>
</ul>
<p>限制（P147）</p>
<ul>
<li>1</li>
<li>无法用于排序</li>
<li>不支持部分索引匹配查找</li>
<li>不支持范围查询</li>
<li>哈希冲突</li>
</ul>
<p>InnoDB 自适应哈希索引</p>
<p>创建自定义哈希索引</p>
<p>wait for solving</p>
<p>哈希冲突：要避免冲突问题，必须要在WHERE条件中带入哈希值和对应列值。</p>
<h3 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h3><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>第七章详解<br>查找文本中的关键词，而不是直接比较索引中的值<br>适用于MATCH AGAINST操作</p>
<h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>三个优点 P152<br>三星系统 P152</p>
<h2 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>如果查询中的列不是独立的，则MySQL就不会使用索引。 </p>
<h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><p>索引的选择性：不重复的索引值和数据表的记录总数的比值。</p>
<p>对于BLOB，TEXT或者很长的VARCHAR类型的索引，必须使用前缀索引。</p>
<p>前缀长度的选择：</p>
<ul>
<li>足够长，保证选择性</li>
<li>不能过长，以便节约空间</li>
</ul>
<p>完整列选择性的计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	SELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref </span><br><span class="line">FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>在同一个查询中计算不同前缀长度的选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3,</span><br><span class="line">COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4,</span><br><span class="line">COUNT(DISTINCT LEFT(city, 5))/COUNT(*) AS sel5,</span><br><span class="line">COUNT(DISTINCT LEFT(city, 6))/COUNT(*) AS sel6,</span><br><span class="line">FROM sakila.city_demo;</span><br></pre></td></tr></table></figure>

<p>创建前缀索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE sakila.city_demo ADD KEY(city(7));</span><br></pre></td></tr></table></figure>

<p>优缺点：</p>
<ul>
<li>使索引更小、更快；</li>
<li>无法使用前缀索引做覆盖扫描，ORDER BY 和 GROUP BY</li>
</ul>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>错误理解：为每个列创建独立的索引<br>这样最好的情况也只是“一星索引”</p>
<p>Warn:</p>
<ul>
<li>出现相交操作时，通常意味着 P158</li>
<li>有些列索引选择性不高的时候 P158</li>
<li>优化器 P158</li>
</ul>
<p>optimizer_switch 开启和关闭索引合并功能</p>
<h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>不考虑排序和分组，只考虑WHERE条件查找的优化：将选择性最高的列放在前面。</p>
<p>根据运行频率最高的查询来调整索引列的顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 583;</span><br><span class="line"></span><br><span class="line">P 160</span><br></pre></td></tr></table></figure>

<p>经验法则考虑全局基数和选择性，不是某个具体查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P 160</span><br></pre></td></tr></table></figure>

<p>特殊情况：</p>
<p>管理员账户，标记为guest的条目：关联了很多条数据</p>
<p>解决方案：</p>
<p>修改应用程序代码，区分这类特殊用户和组，禁止针对这类用户和组执行这个查询。</p>
<p>总结：</p>
<p>选择性和基数；WHERE中的排序，分组和范围条件。</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>不是一种单独的索引类型，而是一种数据存储方式。<br>InnoDB的聚簇索引在同一个结构中保存了B-Tree索引和数据行。</p>
<p>优缺点： P163</p>
<ul>
<li>相关数据保存在一起</li>
<li>数据访问更快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点的主键值。</li>
<li></li>
<li>适合I/O密集型，数据在内存中，则无优势</li>
<li>插入速度依赖于插入顺序 OPTIMIZE_TABLE</li>
<li>更新代价很高</li>
<li>页分裂</li>
<li>全表扫描变慢</li>
</ul>
<p>节点数据 P166</p>
<p>在InnoDB表中<strong>按主键顺序插入行</strong></p>
<p>定义代理键为主键，主键数据应该和应用无关，最简单的方法是使用AUTO_INCREMENT自增列</p>
<p>原因： P170</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><h3 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h3><h3 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h3><h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h3><h3 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h3><h3 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h3><h2 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h2><ul>
<li>虽然有些列选择性低，但考虑到使用频率，还是应该在其上建立索引。</li>
<li>同时优化索引和查询</li>
<li>尽可能将范围查询的列放在索引的后面</li>
<li>可以通过IN()跳过B-tree的限制，但不能使用太多</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>选择索引和编写查询时的三原则：P192</p>
<ul>
<li>单行访问是很慢的</li>
<li>按顺序访问范围数据很快：避免随机IO，不需要多次磁盘寻道；不需要额外的排序操作</li>
<li>索引的覆盖查询很快</li>
</ul>
<p>判断索引是否合理：P193</p>
<ul>
<li>按响应时间进行分析</li>
<li>扫描太多行，很多额外排序，临时表，随机IO，太多回表查询</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="lock和latch"><a href="#lock和latch" class="headerlink" title="lock和latch"></a>lock和latch</h3><p>概念比较底层 P250</p>
<p>InnoDB中的锁</p>
<p>​    锁的类型</p>
<p>​    一致性非锁定读</p>
<p>​    一致性锁定读</p>
<p>锁的算法</p>
<p>锁问题</p>
<p>阻塞</p>
<p>死锁</p>
<p>锁升级</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/mysteryhaohao/article/details/51669741" target="_blank" rel="noopener">https://blog.csdn.net/mysteryhaohao/article/details/51669741</a></p>
<p><strong>行锁，表锁，页锁</strong></p>
<p><strong>开销、加锁速度、死锁、粒度、并发性能</strong></p>
<p>表锁：<br>开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低<br>行锁：<br>开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高<br>页锁：<br>开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</p>
<h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a><strong>MyISAM表锁</strong></h3><p>MyISAM存储引擎只支持表锁（此后出现支持页锁的BDB存储引擎和支持行锁的InnoDB存储引擎）</p>
<p>通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;table%&apos;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Table_locks_immediate | 2979  |</span><br><span class="line">| Table_locks_waited    | 0     |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">2 rows in set (0.00 sec))</span><br></pre></td></tr></table></figure>

<p>如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。</p>
<h4 id="MySQL表级锁的锁模式"><a href="#MySQL表级锁的锁模式" class="headerlink" title="MySQL表级锁的锁模式"></a>MySQL表级锁的锁模式</h4><p>MySQL的表级锁有两种模式：<strong>表共享读锁（Table Read Lock）</strong>和<strong>表独占写锁（Table Write Lock）</strong>。读锁：共享锁，写锁：排他锁</p>
<p>锁模式的兼容性如下表所示。         </p>
<p><img src="C:%5CUsers%5Ccheny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582773943794.png" alt="1582773943794"></p>
<p>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；<br>对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；<br>当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p>
<h4 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h4><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁.<br>这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Select sum(total) from orders;</span><br><span class="line">Select sum(subtotal) from order_detail;</span><br></pre></td></tr></table></figure>

<p>这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lock tables orders read local, order_detail read local;</span><br><span class="line">Select sum(total) from orders;</span><br><span class="line">Select sum(subtotal) from order_detail;</span><br><span class="line">Unlock tables;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的例子在LOCK TABLES时加了“local”选项，其作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录。</li>
<li>在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL<strong>不支持锁升级</strong>。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。<br>其实，在自动加锁的情况下也基本如此，<u>MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因</u>。</li>
</ul>
<p><strong>在如下表所示的例子中</strong>，一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但<u>更新或访问其他表都会提示错误</u>；同时，<u>另外一个session可以查询表中的记录，但更新就会出现锁等待</u>。</p>
<p>★ e.g.</p>
<p><strong>注意，</strong>当使用LOCK TABLES时，不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁定多少次，否则也会出错！</p>
<h4 id="并发插入（Concurrent-Inserts）"><a href="#并发插入（Concurrent-Inserts）" class="headerlink" title="并发插入（Concurrent Inserts）"></a>并发插入（Concurrent Inserts）</h4><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。</p>
<ul>
<li>当concurrent_insert设置为0时，不允许并发插入。</li>
<li>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。</li>
<li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</li>
</ul>
<p>session_1获得了一个表的READ LOCAL锁，该线程可以对表进行查询操作，但不能对表进行更新操作；<br>其他的线程（session_2），虽然不能对表进行删除和更新操作，但却可以对该表进行并发插入操作。</p>
<p>可以利用MyISAM存储引擎的并发插入特性，来<u>解决应用中对同一表查询和插入的锁争用</u>。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行 OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。</p>
<h4 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a><strong>MyISAM的锁调度</strong></h4><p>前面讲过，MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个 MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为MySQL认为写请求一般比读请求要重要。</p>
<p>这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！</p>
<ul>
<li>幸好我们可以通过一些设置来调节MyISAM 的调度行为。</li>
<li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</li>
<li>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</li>
<li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li>
</ul>
<p>虽然上面3种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如<strong>用户登录系统</strong>）中，读锁等待严重的问题。</p>
<p>另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</p>
<p>上面已经讨论了写优先调度机制带来的问题和解决办法。这里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”！因此，应用中应<u>尽量避免出现长时间运行的查询操作</u>，不要总想用一条SELECT语句来解决问题，因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用<strong>中间表等措施</strong>对SQL语句做一定的“分解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。</p>
<h3 id="InnoDB锁问题"><a href="#InnoDB锁问题" class="headerlink" title="InnoDB锁问题"></a><strong>InnoDB锁问题</strong></h3><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</p>
<h4 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h4><ul>
<li>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</li>
<li>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。</li>
<li>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。</li>
<li>幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>在上面讲到的并发事务处理带来的问题中，“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，<u>防止更新丢失应该是应用的责任</u>。</p>
<p>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本上可分为以下两种。</p>
<ul>
<li>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li>
<li>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</li>
</ul>
<p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p>
<p><img src="C:%5CUsers%5Ccheny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582776407285.png" alt="1582776407285"></p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><p>InnoDB行锁是通过<strong><u>给索引上的索引项加锁</u></strong>来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。</p>
<p>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p>
<p>例子：</p>
<p>（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。</p>
<p>在如上表所示的例子中，看起来session_1只给一行加了排他锁，<u>但session_2在请求其他行的排他锁时</u>，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁。当我们给其增加一个索引后，InnoDB就只锁定了符合条件的行，如下表所示。</p>
<p>（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。</p>
<p>索引键相同，其他查询条件不同，也会等待。</p>
<p>（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</p>
<p>e.g.</p>
<p>（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，<strong>在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</strong></p>
<h3 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）"></a><strong>间隙锁（Next-Key锁）</strong></h3><h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>定义：读到未提交更新的数据</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>取出500元把余额改为500元</td>
</tr>
<tr>
<td>T5</td>
<td>查询账户余额为500元（脏读）</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>撤销事务</strong>，余额恢复为1000元</td>
</tr>
<tr>
<td>T7</td>
<td>存入100元把余额改为600元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><strong>提交事务</strong></td>
<td></td>
</tr>
</tbody></table>
<p>A事务查询到了B事务未提交的更新数据，A事务依据这个查询结果继续执行相关操作。但是接着B事务撤销了所做的更新，这会导致A事务操作的是脏数据，以上的示例中T5时刻产生了脏读，最终导致A事务提交时账户余额的不正确，可能有人会有疑问，B事务还没有提交或撤销，T5时刻A事务为什么能读到已经改变的数据，这里要说的是，数据表中的数据是实时改变的，事务只是控制数据的最终状态，也就是说如果没有正确的隔离级别，在更新操作语句结束后，即使事务未完成，其他事务就已经可以读取到改变的数据值了。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>定义：读到已经提交更新的数据，但一个事务范围内两个相同的查询却返回了不同数据。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元把余额改为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>提交事务</strong></td>
</tr>
<tr>
<td>T7</td>
<td>查询账户余额为900元（与T4读取的一不一致，不可重复读）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h2><h3 id="第一类丢失更新"><a href="#第一类丢失更新" class="headerlink" title="第一类丢失更新"></a>第一类丢失更新</h3><p>定义：A事务撤销时，把已经提交的B事务的更新数据覆盖了。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T3</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>存入100元把余额改为1100元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>提交事务</strong></td>
</tr>
<tr>
<td>T7</td>
<td>取出100元把余额改为900元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><strong>撤销事务</strong></td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>余额恢复为1000元（丢失更新）</td>
<td></td>
</tr>
</tbody></table>
<p>以上的示例演示了第一类丢失更新问题，事务B虽然成功了，但是它所做的更新没有被永久存储，这种并发问题是由于完全没有隔离事务造成的。当两个事务更新相同的数据时，如果一个事务被提交，另一个事务却撤销，那么会连同第一个事务所做的更新也被撤销了。（这是绝对避免出现的事情） 事务A的开始时间和结束时间包含事务B的开始和结束时间,事务A回滚事务的同时,把B的已经提交的事务也回滚的,这是避免的,这就是第一类丢失更新.</p>
<h3 id="第二类丢失更新"><a href="#第二类丢失更新" class="headerlink" title="第二类丢失更新"></a>第二类丢失更新</h3><p>定义：A事务提交时，把已经提交的B事务的更新数据覆盖了。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td><strong>开始事务</strong></td>
</tr>
<tr>
<td>T2</td>
<td><strong>开始事务</strong></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元把余额改为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td><strong>提交事务</strong></td>
</tr>
<tr>
<td>T7</td>
<td>存入100元把余额改为1100</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td><strong>提交事务</strong></td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>余额恢复为1100元（丢失更新）</td>
<td></td>
</tr>
</tbody></table>
<p>第二类丢失更新和第一类的区别实际上是对数据的影响是由A事务的撤销还是提交造成的，它和不可重复读(下面介绍)本质上是同一类并发问题，通常把它看做是不可重复读的一个特例。两个或多个事务查询同一数据。然后都基于自己的查询结果更新数据，这时会造成最后一个提交的更新事务，将覆盖其它已经提交的更新事务。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="串行化-Serializable，SQLite默认模式）："><a href="#串行化-Serializable，SQLite默认模式）：" class="headerlink" title="串行化(Serializable，SQLite默认模式）："></a>串行化(Serializable，SQLite默认模式）：</h3><p>最高级别的隔离。两个同时发生的事务100%隔离，每个事务有自己的”世界”, 串行执行。</p>
<p>在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题。</p>
<h3 id="可重复读（Repeatable-read，MySQL默认模式）："><a href="#可重复读（Repeatable-read，MySQL默认模式）：" class="headerlink" title="可重复读（Repeatable read，MySQL默认模式）："></a>可重复读（Repeatable read，MySQL默认模式）：</h3><p>如果一个事务成功执行并且添加了新数据(事务提交)，这些数据对其他正在执行的事务是可见的。但是如果事务成功修改了一条数据，修改结果对正在运行的事务不可见。所以，<u>事务之间只是在新数据方面突破了隔离，对已存在的数据仍旧隔离</u>。</p>
<h3 id="读取已提交（Read-committed，Oracle、PostgreSQL、SQL-Server默认模式）："><a href="#读取已提交（Read-committed，Oracle、PostgreSQL、SQL-Server默认模式）：" class="headerlink" title="读取已提交（Read committed，Oracle、PostgreSQL、SQL Server默认模式）："></a>读取已提交（Read committed，Oracle、PostgreSQL、SQL Server默认模式）：</h3><p>可重复读+新的隔离突破。如果事务A读取了数据D，然后数据D被事务B修改（或删除）并提交，事务A再次读取数据D时数据的变化（或删除）是可见的。这叫不可重复读（non-repeatable read）。</p>
<h3 id="读取未提交（Read-uncommitted）："><a href="#读取未提交（Read-uncommitted）：" class="headerlink" title="读取未提交（Read uncommitted）："></a>读取未提交（Read uncommitted）：</h3><p>最低级别的隔离，是读取已提交+新的隔离突破。如果事务A读取了数据D，然后数据D被事务B修改（但并未提交，事务B仍在运行中），事务A再次读取数据D时，数据修改是可见的。如果事务B回滚，那么事务A第二次读取的数据D是无意义的，因为那是事务B所做的从未发生的修改（已经回滚了嘛）。这叫脏读（dirty read）。</p>
<p><strong>不可重复读和幻读的区别：</strong> 简单来说，不可重复读是由于数据修改引起的，幻读是由数据插入或者删除引起的。</p>
<p><img src="C:%5CUsers%5Ccheny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1584198276306.png" alt="1584198276306"></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，导致恶性循环。</p>
<h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><p>不好的方式：设置查询的超时时间</p>
<p>InnoDB的简单解决方式：将持有最少行级排他锁</p>
<p>死锁发生之后，只有部分或完全回滚其中一个事务，才能打破死锁。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。</p>
<p>在InnoDB中的工作原理：<br>在每行记录后面保存两个隐藏的列。<br>这两个列，一个保存了行的创建时间，一个保存过期时间（删除时间）。</p>
<p>SELECT<br>INSERT<br>DELETE<br>UPDATE<br><img src="C:%5CUsers%5Ccheny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1584200464847.png" alt="1584200464847"></p>
<p>优点：大多数读操作不用加锁，……<br>不足：每行记录都要额外的存储空间，需要更多的行检查工作</p>
<p><img src="C:%5CUsers%5Ccheny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1584200422232.png" alt="1584200422232"></p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>处理短期事务<br>采用MVCC实现高并发，实现了四个便准的隔离级别，默认为可重复读，通过间隙锁避免幻读<br>基于聚簇索引建表。聚簇索引对主键查询有很高性能，但二级索引必须包含主键索引（主键定义的长度越小，二级索引的大小就越小，这样每个磁盘块存储的索引数据越多，查询效率就越高）。<br>可预测性预读：自动创建hash索引<br>加速插入操作：插入缓冲区</p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>全文索引，压缩，空间函数（GIS）<br>不支持事务和行级锁<br>适用场景：只读数据，表比较小，可以忍受修复（repair）操作。<br>加锁与并发：表锁<br>修复：<br>索引：全文索引<br>延迟更新索引键：清理缓冲区，关闭表，提升写入性能<br>压缩表：减少磁盘空间占用，减少磁盘I/O，提升查询性能。修改需要解压缩，无需全表解压。<br>性能：典型问题 – 表锁</p>
<h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><h2 id="JOIN关键字"><a href="#JOIN关键字" class="headerlink" title="JOIN关键字"></a>JOIN关键字</h2><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p><strong>最基本的分页方式：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">LIMIT</span> ...</span><br></pre></td></tr></table></figure>

<p>在中小数据量的情况下，这样的SQL足够用了，唯一需要注意的问题就是确保使用了索引：<br>举例来说，如果实际SQL类似下面语句，那么在category_id, id两列上建立复合索引比较好：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> category_id = <span class="number">123</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">LIMIT</span> <span class="number">50</span>, <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>子查询的分页方式：</strong></p>
<p>随着数据量的增加，页数会越来越多，查看后几页的SQL就可能类似：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> category_id = <span class="number">123</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">LIMIT</span> <span class="number">10000</span>, <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>一言以蔽之，就是越往后分页，<code>LIMIT语句的偏移量就会越大，速度也会明显变慢</code>。<br>此时，我们可以通过子查询的方式来提高分页效率，大致如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span>  <span class="keyword">id</span> &gt;=  </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> articles  <span class="keyword">WHERE</span> category_id = <span class="number">123</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">LIMIT</span> <span class="number">10000</span>, <span class="number">1</span>) <span class="keyword">LIMIT</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>JOIN分页方式</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`content`</span> <span class="keyword">AS</span> t1   </span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> <span class="string">`content`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">LIMIT</span> <span class="string">".($page-1)*$pagesize."</span>, <span class="number">1</span>) <span class="keyword">AS</span> t2   </span><br><span class="line"><span class="keyword">WHERE</span> t1.id &lt;= t2.id <span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.id <span class="keyword">desc</span> <span class="keyword">LIMIT</span> $pagesize;</span><br></pre></td></tr></table></figure>

<p>经过我的测试，join分页和子查询分页的效率基本在一个等级上，消耗的时间也基本一致。<br>explain SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id select_type table type possible_keys key key_len ref rows Extra</span><br><span class="line">1 PRIMARY &lt;derived2&gt; system NULL NULL NULL NULL 1  </span><br><span class="line">1 PRIMARY t1 range PRIMARY PRIMARY 4 NULL 6264 Using where</span><br><span class="line">2 DERIVED content index NULL PRIMARY 4 NULL 27085 Using index</span><br></pre></td></tr></table></figure>

<p>为什么会这样呢？因为子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。</p>
<p>实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。</p>
<h3 id="LIMIT分页存在的问题"><a href="#LIMIT分页存在的问题" class="headerlink" title="LIMIT分页存在的问题"></a>LIMIT分页存在的问题</h3><p>查询从第1000000之后的30条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SQL代码1：平均用时6.6秒 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`cdb_posts`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> pid <span class="keyword">LIMIT</span> <span class="number">1000000</span> , <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>代码<span class="number">2</span>：平均用时<span class="number">0.6</span>秒 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`cdb_posts`</span> <span class="keyword">WHERE</span> pid &gt;= (<span class="keyword">SELECT</span> pid <span class="keyword">FROM</span>  </span><br><span class="line"><span class="string">`cdb_posts`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> pid <span class="keyword">LIMIT</span> <span class="number">1000000</span> , <span class="number">1</span>) <span class="keyword">LIMIT</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>因为要<strong>取出所有字段内容</strong>，第一种需要跨越大量数据块并取出，而第二种基本通过直接<strong>根据索引字段定位后，才取出相应内容</strong>，效率自然大大提升。对limit的优化，不是直接使用limit，而是首先获取到offset的id，然后直接使用limit size来获取数据。</p>
<p>可以看出，越往后分页，LIMIT语句的偏移量就会越大，两者速度差距也会越明显。</p>
<p>实际应用中，可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。</p>
<p><img src="https://segmentfault.com/img/bVLlt0?w=671&h=118" alt="clipboard.png"></p>
<p><img src="https://segmentfault.com/img/bVLluR?w=881&h=307" alt="clipboard.png"></p>
<p><strong>为了保证index索引列连续，可以为每个表加一个自增字段，并且加上索引</strong></p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>库：database；表：table；分库分表：sharding</p>
<h3 id="数据库架构演变"><a href="#数据库架构演变" class="headerlink" title="数据库架构演变"></a><strong>数据库架构演变</strong></h3><p>刚开始我们只用单机数据库就够了，随后面对越来越多的请求，我们将数据库的写操作和读操作进行分离， 使用多个从库副本（Slaver Replication）负责读，使用主库（Master）负责写， 从库从主库同步更新数据，保持数据一致。架构上就是数据库主从同步。 从库可以水平扩展，所以更多的读请求不成问题。</p>
<p>但是当用户量级上来后，写请求越来越多，该怎么办？<u>加一个Master是不能解决问题的， 因为数据要保存一致性，写操作需要2个master之间同步，相当于是重复了，而且更加复杂</u>。</p>
<p>这时就需要用到分库分表（sharding），对写操作进行切分。</p>
<h2 id="分库分表前的问题"><a href="#分库分表前的问题" class="headerlink" title="分库分表前的问题"></a>分库分表前的问题</h2><p><strong>用户请求量太大</strong></p>
<p>因为单服务器TPS，内存，IO都是有限的。 解决方法：<u>分散请求到多个服务器上</u>； 其实用户请求和执行一个sql查询是本质是一样的，都是请求一个资源，只是用户请求还会经过网关，路由，http服务器等。</p>
<p><strong>单库太大</strong></p>
<p>单个数据库处理能力有限；<u>单库所在服务器上磁盘空间不足；单库上操作的IO瓶颈</u><br>解决方法：切分成更多更小的库</p>
<p><strong>单表太大</strong></p>
<p>CRUD都成问题；<u>索引膨胀，查询超时</u><br>解决方法：切分成多个数据集更小的表。</p>
<h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>也就是“大表拆小表”，基于列字段进行的。<u>一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表”</u>。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">垂直分割指的是：表的记录并不多，但是字段却很长，表占用空间很大，检索表的时候需要执行大量的IO，严重降低了性能。这时需要把大的字段拆分到另一个表，并且该表与原表是一对一的关系。</span><br><span class="line"></span><br><span class="line">例如学生答题表tt：有如下字段：</span><br><span class="line"></span><br><span class="line">Id name 分数 题目 回答</span><br><span class="line"></span><br><span class="line">其中题目和回答是比较大的字段，id name 分数比较小。</span><br><span class="line"></span><br><span class="line">如果我们只想查询id为8的学生的分数：select 分数 from tt where id = 8;虽然知识查询分数，但是题目和回答这两个大字段也是要被扫描的，很消耗性能。但是我们只关心分数，并不想查询题目和回答。这就可以使用垂直分割。我们可以把题目单独放到一张表中，通过id与tt表建立一对一的关系，同样将回答单独放到一张表中。这样我们插叙tt中的分数的时候就不会扫描题目和回答了。</span><br></pre></td></tr></table></figure>

<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 按照业务模块进行划分。切分后，要放在多个服务器上，而不是一个服务器上。为什么？ 我们想象一下，一个购物网站对外提供服务，会有用户，商品，订单等的CRUD。没拆分之前， 全部都是落到单一的库上的，这会让数据库的单库处理能力成为瓶颈。按垂直分库后，如果还是放在一个数据库服务器上， 随着用户量增大，这会让单个数据库的处理能力成为瓶颈，还有<u>单个服务器的磁盘空间，内存，tps等非常吃紧</u>。 所以我们要拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。</p>
<p>数据库业务层面的拆分，和服务的“治理”，“降级”机制类似，也能对不同业务的数据分别的进行管理，维护，监控，扩展等。 数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。 <u>数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。</u></p>
<h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。</p>
<h3 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h3><p>将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例：QQ的登录表。假设QQ的用户有100亿，如果只有一张表，每个用户登录的时候数据库都要从这100亿中查找，会很慢很慢。如果将这一张表分成100份，每张表有1亿条，就小了很多，比如qq0,qq1,qq1...qq99表。</span><br><span class="line"></span><br><span class="line">用户登录的时候，可以将用户的id%100，那么会得到0-99的数，查询表的时候，将表名qq跟取模的数连接起来，就构建了表名。比如123456789用户，取模的89，那么就到qq89表查询，查询的时间将会大大缩短。</span><br></pre></td></tr></table></figure>

<h3 id="水平分库分表切分规则"><a href="#水平分库分表切分规则" class="headerlink" title="水平分库分表切分规则"></a>水平分库分表切分规则</h3><p>1.RANGE</p>
<p>从0到10000一个表，10001到20000一个表</p>
<p>2.HASH取模</p>
<p>一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。</p>
<p>3.地理区域</p>
<p>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</p>
<p>4.时间</p>
<p>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“<u>冷热数据分离</u>”。</p>
<h2 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h2><h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p>分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>
<h3 id="多库结果集合并（group-by，order-by）"><a href="#多库结果集合并（group-by，order-by）" class="headerlink" title="多库结果集合并（group by，order by）"></a>多库结果集合并（group by，order by）</h3><p>TODO</p>
<h3 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h3><p>TODO 分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。 粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。</p>
<h2 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h2><p>1)存放图片、文件等大文件用文件<a href="https://www.2cto.com/os/" target="_blank" rel="noopener">系统</a>存储。数据库只存储路径，图片和文件存放在文件系统，甚至单独存放在一台服务器(图床)。</p>
<p>2)数据参数配置。</p>
<p>最重要的参数就是内存，我们主要用的innodb引擎，所以下面两个参数调的很大：</p>
<p>innodb_additional_mem_pool_size=64M</p>
<p>innodb_buffer_pool_size=1G</p>
<p>对于MyISAM，需要调整key_buffer_size，当然调整参数还是要看状态，用show status语句可以看到当前状态，以决定该调整哪些参数。</p>
<p>4，合理的硬件资源和操作系统</p>
<p>如果机器的内存超过4G，那么应当采用64位操作系统和64位MySQL。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/面经/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/面经/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h2><p>reference:<br><a href="https://blog.csdn.net/u012512634/article/details/72735183" target="_blank" rel="noopener">https://blog.csdn.net/u012512634/article/details/72735183</a><br><a href="https://blog.csdn.net/wenyiqingnianiii/article/details/52204136" target="_blank" rel="noopener">https://blog.csdn.net/wenyiqingnianiii/article/details/52204136</a></p>
<h2 id="StringBuilder-amp-amp-StringBuffer"><a href="#StringBuilder-amp-amp-StringBuffer" class="headerlink" title="StringBuilder &amp;&amp; StringBuffer"></a>StringBuilder &amp;&amp; StringBuffer</h2><p>append(String s), reverse, delete(int start, int end), insert, replace(int start, int end, String str)<br>类似String: capacity, charAt(int index), indexOf(string str), length, substring(int start / int start, int end), toString</p>
<p>StringBuffer 线程安全</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><h1 id="线程-进程"><a href="#线程-进程" class="headerlink" title="线程/进程"></a>线程/进程</h1><h2 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>进程:具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是<strong>系统进行资源分配和调度</strong>的一个独立单位.</p>
<p>线程:进程的一个实体, 是<strong>CPU调度和分派的基本单位</strong>,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(<strong>如程序计数器,一组寄存器和栈</strong>),但是它<u>可与同属一个进程的其他的线程共享进程所拥有的全部资源</u>.</p>
<h3 id="2-关系"><a href="#2-关系" class="headerlink" title="2. 关系"></a>2. 关系</h3><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的<strong>栈空间</strong>，拥有独立的<strong>执行序列</strong>。</p>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><p>进程和线程的主要差别在于它们是<strong>不同的操作系统资源管理方式</strong>。</p>
<p>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。</p>
<p>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<strong>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</strong></p>
<p>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p>
<p>2) 线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
<p>3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。<strong>但是线程不能够独立执行，</strong>必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。<strong>这就是进程和线程的重要区别。</strong></p>
<p><strong>4.优缺点</strong></p>
<p>线程和进程在使用上各有优缺点：</p>
<p>线程执行开销小，但不利于资源的管理和保护；</p>
<p>而进程正相反。</p>
<p>同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>
<h2 id="Java进程间通信"><a href="#Java进程间通信" class="headerlink" title="Java进程间通信"></a>Java进程间通信</h2><h3 id="1-进程间通信目的及方式"><a href="#1-进程间通信目的及方式" class="headerlink" title="1. 进程间通信目的及方式"></a>1. 进程间通信目的及方式</h3><p>目的：</p>
<p>1、数据传输<br>一个进程需要将它的数据发送给另一个进程。<br>2、资源共享<br>多个进程之间共享同样的资源。<br>3、通知事件<br>一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件<br>4、进程控制<br>有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
<p>方式：</p>
<ol>
<li>管道( pipe )：<br>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指<strong>父子进程</strong>关系。</li>
<li>有名管道 (namedpipe) ：<br>有名管道也是半双工的通信方式，但是它允许<strong>无亲缘关系</strong>进程间的通信。</li>
<li>信号量(semophore ) ：<br>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>消息队列( messagequeue ) ：<br>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了<strong>信号传递信息少</strong>、<strong>管道只能承载无格式字节流</strong>以及<strong>缓冲区大小受限</strong>等缺点。</li>
<li>信号 (sinal ) ：<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>共享内存(shared memory ) ：<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
<li>套接字(socket ) ：<br>套接口也是一种进程间通信机制，与其他通信机制不同的是，它<strong>可用于不同设备及其间的进程通信</strong>。</li>
</ol>
<h3 id="2-线程间通信"><a href="#2-线程间通信" class="headerlink" title="2. 线程间通信"></a>2. 线程间通信</h3><ol>
<li><p>锁机制：包括互斥锁、条件变量、读写锁<br>互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p>
</li>
<li><p>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</p>
</li>
<li><p>信号机制(Signal)：类似进程间的信号处理</p>
</li>
</ol>
<p>   <u>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</u></p>
<p> 强引用和弱引用 </p>
<h2 id="如何实现LRU"><a href="#如何实现LRU" class="headerlink" title="如何实现LRU"></a>如何实现LRU</h2><p>reference:<br><a href="https://zhuanlan.zhihu.com/p/34133067" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34133067</a></p>
<h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 悲观锁"></a>乐观锁 悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。</p>
<p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。</p>
<p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h4 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h4><p>后面的技术问题涉及广度很深包括但不限于TCP IP, 数据库，socket编程，异步编程，动态规划与递归，多线程编程， HTTP等。</p>
<p>hashArray和list有什么区别？</p>
<p>内存单元的作用是什么</p>
<p>刚开始就让敲代码，实现快速排序算法、二叉树的中序遍历（非递归）、实现线程安全的火车票销售，之后问了线程池的知识，ThreadPoolExecuter还问了Object类里的方法，接着问了计算机网络方面的，之后还问了数据库的ACID、左连接和右连接，我一般用的是Oracle，就问了Oracle里面一些函数的用法，但是没有让写SQL。最后就是问我还有什么问题，就是这些了</p>
<p>乐观锁，悲观锁</p>
<h2 id="输入url到返回页面的全过程"><a href="#输入url到返回页面的全过程" class="headerlink" title="输入url到返回页面的全过程"></a>输入url到返回页面的全过程</h2><h3 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h3><p><a href="https://www.jianshu.com/p/184ebd448c7f?mType=Group" target="_blank" rel="noopener">https://www.jianshu.com/p/184ebd448c7f?mType=Group</a></p>
<ul>
<li>1.根据域名，进行DNS域名解析；</li>
<li>2.拿到解析的IP地址，建立TCP连接；</li>
<li>3.向IP地址，发送HTTP请求；</li>
<li>4.服务器处理请求；</li>
<li>5.返回响应结果；</li>
<li>6.关闭TCP连接；</li>
<li>7.浏览器解析HTML；</li>
<li>8.浏览器布局渲染；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20170420081600446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHNkMjAxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>reference:<br><a href="https://zhuanlan.zhihu.com/p/79350395" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79350395</a></p>
<p>DNS 的全称是 Domain Name System 或者 Domain Name Service，它主要的作用就是将人们所熟悉的网址 (域名) “翻译”成电脑可以理解的 IP 地址，这个过程叫做 DNS 域名解析。</p>
<p>大致就是:浏览器输入地址，然后浏览器这个进程去调操作系统某个库里的gethostbyname函数(例如，Linux GNU glibc标准库的gethostbyname函数)，然后这个函数通过网卡给DNS服务器发UDP请求，接收结果，然后将结果给返回给浏览器。</p>
<p>这张图其实已经讲明白大致的流程，但是细节上可能有些差异。 例如</p>
<ul>
<li>(1)我们在用chrome浏览器的时候，其实会先去浏览器的dns缓存里头查询，dns缓存中没有，再去调用gethostbyname函数</li>
<li>(2)gethostbyname函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，如果没找到再去DNS服务器上查</li>
</ul>
<p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。<br>当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 这种情况下，使用TCP协议。</p>
<p><strong>针对第一问，<em>为什么域名解析用UDP协议?</em></strong></p>
<p>因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手。但是UDP协议传输内容不能超过512字节。不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。</p>
<p><strong>针对第二问，<em>为什么区域传送用TCP协议？</em></strong></p>
<p>因为TCP协议可靠性好啊！因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？</p>
<p><img src="https://pic3.zhimg.com/80/v2-9ea11047f720b3b74c5846256c1883da_1440w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-065d69d1ec2f516e6d24ed3514ebd59b_1440w.png" alt="img"></p>
<p>未完</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="长连接-短连接"><a href="#长连接-短连接" class="headerlink" title="长连接 短连接"></a>长连接 短连接</h2><h3 id="1-HTTP协议与TCP-IP协议的关系"><a href="#1-HTTP协议与TCP-IP协议的关系" class="headerlink" title="1. HTTP协议与TCP/IP协议的关系"></a><strong>1. HTTP协议与TCP/IP协议的关系</strong></h3><p>　　HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。<br>IP协议主要解决网络路由和寻址问题。<br>TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p>
<h3 id="2-如何理解HTTP协议是无状态的"><a href="#2-如何理解HTTP协议是无状态的" class="headerlink" title="2. 如何理解HTTP协议是无状态的"></a><strong>2. 如何理解HTTP协议是无状态的</strong></h3><p>　　HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>
<h3 id="3-什么是长连接、短连接？"><a href="#3-什么是长连接、短连接？" class="headerlink" title="3. 什么是长连接、短连接？"></a><strong>3. 什么是长连接、短连接？</strong></h3><p>　　<strong>在HTTP/1.0中，默认使用的是短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>
<p>但从 <strong>HTTP/1.1起，默认使用长连接</strong>，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Connection:keep-alive`</span><br></pre></td></tr></table></figure>

<p>　　在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<h2 id="一个-TCP-连接上面能发多少个-HTTP-请求"><a href="#一个-TCP-连接上面能发多少个-HTTP-请求" class="headerlink" title="一个 TCP 连接上面能发多少个 HTTP 请求"></a>一个 TCP 连接上面能发多少个 HTTP 请求</h2><p>reference:<br><a href="https://zhuanlan.zhihu.com/p/61423830" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61423830</a></p>
<p>在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 连接。</p>
<p>HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。</p>
<p>在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：</p>
<ol>
<li>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。</li>
<li>和服务器建立多个 TCP 连接。</li>
</ol>
<p>HTTP2 提供了 Multiplexing 多路传输特性，可以<strong>在一个 TCP 连接中</strong>同时完成多个 HTTP 请求。</p>
<h2 id="TCP-的三次握手和4次挥手过程"><a href="#TCP-的三次握手和4次挥手过程" class="headerlink" title="TCP 的三次握手和4次挥手过程"></a><strong>TCP 的三次握手和4次挥手过程</strong></h2><h2 id="SSL-TLS协议运行机制的概述"><a href="#SSL-TLS协议运行机制的概述" class="headerlink" title="SSL/TLS协议运行机制的概述"></a>SSL/TLS协议运行机制的概述</h2><p>Reference:<br><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p>一面结束问了线程进程，服务器接受访问上限，操作系统如何分配内存，数据库隔离有哪些。一道数学智力题，一个dp。</p>
<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称密钥加密，又称私钥加密，即<strong>信息的发送方和接收方用一个密钥去加密和解密数据</strong>。它的最大优势是<u>加/解密速度快，适合于对大数据量进行加密，但密钥管理困难</u>。</p>
<p>包含算法：</p>
<p>DES、3DES、IDEA、FEAL、BLOWFISH等</p>
<p>二分法，为什么</p>
<h1 id="TPS-and-QPS"><a href="#TPS-and-QPS" class="headerlink" title="TPS and QPS"></a>TPS and QPS</h1><p>TPS:</p>
<p>Transactions Per Second（每秒传输的事物处理个数），即<strong>服务器每秒处理的事务数（事务数/秒）</strong>。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）</p>
<p>TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p>
<p>一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</p>
<p>QPS：</p>
<p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p>
<p>对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</p>
<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><p>设计模式</p>
<p>介绍项目</p>
<h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>对Flask的理解</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>平时怎么使用redis<br>redis常用的数据结构<br>zset<br>Redis遇到无法写入的情况<br>持久化策略</p>
<h2 id="RMQ："><a href="#RMQ：" class="headerlink" title="RMQ："></a>RMQ：</h2><p>为什么会丢消息<br>什么情况下会用消息队列<br>底层队列怎么链接到Exchange</p>
<h2 id="网络-1"><a href="#网络-1" class="headerlink" title="网络:"></a>网络:</h2><p>三次模式，四次挥手<br>http和https<br>ssl<br>对称和非对称密钥<br>TIME_WAIT存在的意义<br>http如何实现长连接，长连接的优点<br>http表头，组成部分<br>ping实现的过程</p>
<h2 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h2><p>提高数据库查询的效率<br>不同引擎之间的区别<br>数据库隔离级别<br>序列化的底层实现<br>索引的数据结构，相比于二叉树的优点<br>join语句</p>
<h2 id="Linux指令："><a href="#Linux指令：" class="headerlink" title="Linux指令："></a>Linux指令：</h2><p>如何查看进程<br>top指令<br>awk</p>
<h2 id="进程和线程："><a href="#进程和线程：" class="headerlink" title="进程和线程："></a>进程和线程：</h2><p>进程和线程的理解<br>多进程单线程和单进程多线程<br>高并发模型<br>如何设计线程池（详细）</p>
<p>Map的底层实现</p>
<p>二进制协议</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>select, epoll<br>epoll的两种模式</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx:"></a>Nginx:</h2><p>Nginx如何做负载均衡<br>常用算法</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>红黑树，如何实现增删改查</p>
<h2 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h2><p>String – Integer<br>二分法：left + [(right - end) / 2] 防止越界<br>快速排序<br>堆排序<br>扫描线算法</p>
<p>前后端连接的方式</p>
<h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><p>JVM的功能<br>垃圾回收机制<br>类的加载过程，类信息的存储</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>服务注册中心的底层实现<br>单体转微服务会遇到的问题<br>什么情况下需要拆分微服务，以及为什么不会继续拆下去</p>
<p>HTTP权威指南</p>
<h2 id="Java网络开发"><a href="#Java网络开发" class="headerlink" title="Java网络开发"></a>Java网络开发</h2><p>AIO, BIO</p>
<p>word search</p>
<p>BFS 2</p>
<p>divide conquer</p>
<p>DP</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul>
<li>项目中某个比较重要的点是如何实现的（需要深入技术的原理）</li>
<li>遇到的最大困难是什么（有哪些），你怎么解决的？</li>
<li>如果需要扩展某个功能，如何降低系统的耦合度</li>
<li>如果针对某个功能进行优化，你会怎么设计和优化</li>
</ul>
<p>1.mysql你都了解哪方面？</p>
<p>2.你做项目时，数据库的查询怎么优化的？</p>
<p>3.有一张表，一天的数据量就达到了几千万，你怎么处理？</p>
<p>4.mysql索引你还能想到怎么优化？</p>
<p>5.mysql索引的最左前缀的底层原理？</p>
<p>6.mysql索引你在使用时还遇过什么问题？</p>
<p>7.mysql使用时不止建一个索引，不用主索引时还会出现你说的问题吗（之前我答的innodb引擎不使用自增字段作为主键对于索引性能的影响）？</p>
<p>8.spring的bean的加载过程，源码看过吗？</p>
<p>9.spring中你知道的用到的设计模式以及用在什么地方？</p>
<p>10.除了刚刚讲的设计模式，你还知道什么设计模式，画出uml图。</p>
<p>11.jdk动态代理讲讲。</p>
<p>12.讲讲java的锁，java的并发控制，比如synchronized底层原理。</p>
<p>13.java并发包中，你都知道什么，讲讲底层实现，实际开发用过吗？</p>
<p>14.你用过什么java中间件吗？</p>
<p>15.讲讲你在做项目时，能体现你技术方面的点。</p>
<p>16.做项目，使用json字符串踩过坑吗？</p>
<p>17.你想问我什么不知道还能不能给二面了？</p>
<p>未解决：</p>
<p>epoll共享内存<br>poll链表存储<br>ICMP协议详解</p>
<p>数据库隔离级别</p>
<p>ping的过程</p>
<p>堆排序</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/设计模式/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://c.biancheng.net/view/1390.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1390.html</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>
<h2 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h2><ol>
<li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于<strong>保存</strong>观察者对象的聚集类和<strong>增加</strong>、<strong>删除</strong>观察者对象的方法，以及<strong>通知所有观察者的抽象方法</strong>。</li>
<li>具体主题（Concrete    Subject）角色：也叫具体目标类，它实现抽象目标中的<strong>通知</strong>方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当<strong>接到具体主题的更改通知时被调用</strong>。</li>
<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时<strong>更新自身的状态</strong>。</li>
</ol>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="http://c.biancheng.net/uploads/allimg/181116/3-1Q1161A6221S.gif" alt="观察者模式的结构图"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Subject subject=<span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1=<span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2=<span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers=<span class="keyword">new</span> ArrayList&lt;Observer&gt;();   </span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体目标发生改变..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);       </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者1作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者2作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>银行汇率<br>铃声通知</p>
<p><strong>Reference:</strong> </p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
</ol>
<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>Observable类</p>
<p>Observer接口</p>
<p>Implementation</p>
<p>……</p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference:"></a>Reference:</h2><p><a href="http://c.biancheng.net/view/1348.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1348.html</a></p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p>
<h2 id="主要角色-1"><a href="#主要角色-1" class="headerlink" title="主要角色"></a>主要角色</h2><ol>
<li>抽象工厂（Abstract Factory）：提供了<strong>创建产品</strong>的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：<strong>定义了产品的规范</strong>，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            af=(AbstractFactory) ReadXML1.getObject();</span><br><span class="line">            a=af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li>
<li>客户不关心创建产品的细节，只关心产品的品牌。</li>
</ul>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>在有些系统中，为了<strong>节省内存资源</strong>、<strong>保证数据内容的一致性</strong>，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p>
<p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p>
<p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点；</li>
</ol>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>懒汉式单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="keyword">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 <strong>volatile 和 synchronized</strong>，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</p>
<p>饿汉式单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。</p>
<p>工厂模式</p>
<p>装饰器模式</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/网络/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h2><h3 id="硬件-软件部分"><a href="#硬件-软件部分" class="headerlink" title="硬件/软件部分"></a>硬件/软件部分</h3><p>“网络服务器（Web server）”可以代指硬件或软件，或者是它们协同工作的整体。</p>
<ol>
<li>硬件部分，一个网络服务器是一台存储了网络服务软件以及网站的组成文件（比如，HTML文档、图片、CSS样式表和JavaScript文件）的计算机。它接入到互联网并且支持与其他连接到互联网的设备进行物理数据的交互。</li>
<li>软件部分，网络服务器包括控制网络用户如何访问托管文件的几个部分，至少他要是一台<strong>HTTP服务器</strong>。<br>一台HTTP服务器是一种能够理解URL（网络地址）和HTTP（浏览器用来查看网页的协议）的软件。通过服务器上存储的网站的域名（比如mozilla.org）可以访问这个服务器，并且他还可以将他的内容分发给最终用户的设备。</li>
</ol>
<p>基本上，当浏览器需要一个托管在网络服务器上的文件的时候，浏览器通过HTTP请求这个文件。当这个请求到达正确的网络服务器（硬件）时，HTTP服务器（软件）收到这个请求，找到这个被请求的文档（如果这个文档不存在，那么将返回一个404响应）， 并把这个文档通过HTTP发送给浏览器。</p>
<p><img src="C:%5CUsers%5Ccheny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583204963742.png" alt="1583204963742"></p>
<h3 id="静态-动态服务器"><a href="#静态-动态服务器" class="headerlink" title="静态/动态服务器"></a>静态/动态服务器</h3><p>要发布一个网站，你需要一个静态或动态的服务器。</p>
<p>静态网络服务器（<strong>static web server</strong>），或者堆栈，由一个计算机（硬件）和一个 HTTP 服务器（软件）组成。我们称它为 “静态” 是因为这个服务器把它托管文件的 “保持原样” 地传送到你的浏览器。</p>
<p>动态网络服务器（<strong>dynamic web server</strong>） 由一个静态的网络服务器加上额外的软件组成，最普遍的是一个应用服务器 [<em>application server</em>] 和一个数据库 [<em>database</em>]。我们称它为 “动态” 是因为这个应用服务器会在通过 HTTP 服务器把托管文件传送到你的浏览器之前会对这些托管文件进行更新。</p>
<p>举个例子，要生成你在浏览器中看到的最终网页，应用服务器或许会用一个数据库中的内容填充一个 HTML 模板。网站像 MDN 或者维基百科 [Wikipedia] 有成千上万的网页，但是它们不是真正的 HTML 文档，它们只是少数的 HTML 模板以及一个巨大的数据库。这样的设置让它更快更简单地维护以及分发内容。</p>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>bind: 绑定端口<br>listen:<br>客户端: connect</p>
<h1 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP / UDP"></a>TCP / UDP</h1><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>应用程序往UDP套接字写入消息 – 封装到UDP数据报 – IP数据报 – 发送</p>
<p>UDP：无连接，客户与服务端无长期关系</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>字节流协议，没有任何记录边界<br>保证数据的可靠递送和故障的可靠通知</p>
<p>动态估算RTT：持续估算<br>排序：给字节关联序列号<br>    分节：TCP传递给IP的数据单元<br>流量控制：可变的通告窗口</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p>请求报文</p>
<p>响应报文</p>
<h2 id="请求报文和响应报文的结构"><a href="#请求报文和响应报文的结构" class="headerlink" title="请求报文和响应报文的结构"></a>请求报文和响应报文的结构</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/系统设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/系统设计/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="系统海量数据存储设计"><a href="#系统海量数据存储设计" class="headerlink" title="系统海量数据存储设计"></a>系统海量数据存储设计</h1><p>京东的商品评论目前已达到数十亿条，每天提供的服务调用也有数十亿次，而这些数据每年还在成倍增长，而数据存储是其中最重要的部分之一，接下来就介绍下京东评论系统的数据存储是如何设计的。</p>
<p>整体数据存储包括基础数据存储、文本存储、数据索引、数据缓存几个部分。</p>
<h2 id="基础数据存储"><a href="#基础数据存储" class="headerlink" title="基础数据存储"></a>基础数据存储</h2><p>基础数据存储使用mysql，因用户评论为文本信息，通常包含文字、字符等，占用的存储空间比较大，为此mysql作为基础数据库只存储非文本的评论基础信息，包括评论状态、用户、时间等基础数据，以及图片、标签、点赞等附加数据。而不同的数据又可选择不同的库表拆分方案，参考如下：</p>
<ul>
<li>评论基础数据按用户ID进行拆库并拆表；</li>
<li>图片及标签处于同一数据库下，根据商品编号分别进行拆表；</li>
<li>其它的扩展信息数据，因数据量不大、访问量不高，处理于同一库下且不做分表即可。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/Unix网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/Unix网络编程/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ukyo317.github.io/2020/03/15/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ukyo Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ukyo Chen's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/Spring/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-15T23:52:37+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p><code>swagger</code>是一款让程序员更好的书写API文档的框架。</p>
<p>REST APIs文档生成工具。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-using-swagger-in-a-spring-boot-project/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-using-swagger-in-a-spring-boot-project/index.html</a><br>在Spring Boot中集成</p>
<h2 id="rap-API文档工具"><a href="#rap-API文档工具" class="headerlink" title="rap API文档工具"></a>rap API文档工具</h2><p>请看，可以填写请求和相应的字段<br><img src="https://img-blog.csdn.net/20170827175556715?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaTY0NDgwMzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>还可以选择字段对应的类型<br><img src="https://img-blog.csdn.net/20170827175340567?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaTY0NDgwMzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>github地址为：<a href="https://github.com/thx/RAP" target="_blank" rel="noopener">https://github.com/thx/RAP</a><br>当然咯，<code>rap</code>不可能只有线上版本，肯定可以部署到私服上。<br><a href="https://github.com/thx/RAP/wiki/deploy_manual_cn" target="_blank" rel="noopener">https://github.com/thx/RAP/wiki/deploy_manual_cn</a></p>
<h2 id="生态使用图"><a href="#生态使用图" class="headerlink" title="生态使用图"></a>生态使用图</h2><p><img src="https://img-blog.csdn.net/20170827202033991?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaTY0NDgwMzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="在Spring-Boot中的应用"><a href="#在Spring-Boot中的应用" class="headerlink" title="在Spring Boot中的应用"></a>在Spring Boot中的应用</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>1.通过在控制器类上增加<code>@Api</code> 注解，可以给控制器增加描述和标签信息。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"用户相关接口"</span>, description = <span class="string">"提供用户相关的 Rest API"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span></span><br></pre></td></tr></table></figure>

<p>2.通过在接口方法上增加 <code>@ApiOperation</code> 注解来展开对接口的描述，当然这个注解还可以指定很多内容，我们在下面的相关注解说明章节中详细解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(<span class="string">"新增用户接口"</span>)</span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addUser</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">    ``<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.实体描述，我们可以通过<code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解来对我们 API 中所涉及到的对象做描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"用户实体"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"用户 id"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.文档信息配置，Swagger 还支持设置一些文档的版本号、联系人邮箱、网站、版权、开源协议等等信息，但与上面几条不同的是这些信息不是通过注解配置，而是通过创建一个 ApiInfo 对象，并且使用 <code>Docket.appInfo()</code> 方法来设置，我们在 SwaggerConfig.java 类中新增如下内容即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.select()</span><br><span class="line">            .apis(RequestHandlerSelectors.any())</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">            <span class="string">"Spring Boot 项目集成 Swagger 实例文档"</span>,</span><br><span class="line">            <span class="string">"我的博客网站：https://itweknow.cn，欢迎大家访问。"</span>,</span><br><span class="line">            <span class="string">"API V1.0"</span>,</span><br><span class="line">            <span class="string">"Terms of service"</span>,</span><br><span class="line">            <span class="keyword">new</span> Contact(<span class="string">"名字想好没"</span>, <span class="string">"https://itweknow.cn"</span>, <span class="string">"gancy.programmer@gmail.com"</span>),</span><br><span class="line">                <span class="string">"Apache"</span>, <span class="string">"http://www.apache.org/"</span>, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面的步骤，文档将会变成下图的样子，现在看起来就清楚很多了。</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-using-swagger-in-a-spring-boot-project/image002.png" alt="img"></p>
<h1 id="LDAP用法"><a href="#LDAP用法" class="headerlink" title="LDAP用法"></a>LDAP用法</h1><h2 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h2><p>Person.java</p>
<p>Person中字段为<strong>需要从Ldap中查询的数据字段</strong>，利用注解@Attribute(name=“xx”)进行注解,Entry中定义的<strong>objectClass和base为Ldap中数据资源的定位信息</strong>。查询的时候可以作为返回对象来接收数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entry</span>(objectClasses = &#123;<span class="string">"bicPersonExt"</span>, <span class="string">"bicPerson"</span>&#125;, base = <span class="string">"ou=person,dc=coreservice"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Attribute</span></span><br><span class="line">    <span class="keyword">private</span> String personId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 人员姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Attribute</span>(name = <span class="string">"cn"</span>)</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组织ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Attribute</span>(name = <span class="string">"orgId"</span>)</span><br><span class="line">    <span class="keyword">private</span> String orgId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 性别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Attribute</span>(name = <span class="string">"sex"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Attribute</span>(name = <span class="string">"mobile"</span>)</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Attribute</span>(name = <span class="string">"email"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Attribute</span>(name = <span class="string">"jobNo"</span>)</span><br><span class="line">    <span class="keyword">private</span> String jobNo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IOC和AOP"><a href="#IOC和AOP" class="headerlink" title="IOC和AOP"></a>IOC和AOP</h1><p>IOC</p>
<p>工厂模式的应用</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="References-1"><a href="#References-1" class="headerlink" title="References:"></a>References:</h3><p><a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/aop.html#aop-schema" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/aop.html#aop-schema</a></p>
<h3 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h3><p><strong>Aspect</strong>:</p>
<p>Two Methods: </p>
<ol>
<li>In Spring AOP, aspects are implemented using regular classes (the <a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/aop.html#aop-schema" target="_blank" rel="noopener">schema-based approach</a>)</li>
<li>regular classes annotated with the <code>@Aspect</code> annotation (the <a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/aop.html#aop-ataspectj" target="_blank" rel="noopener"><code>@AspectJ</code> style</a>).</li>
</ol>
<p><strong>Join Point</strong></p>
<p>a point during the execution of a program, such as the execution of a method or the handling of an exception.<br>In Spring AOP, a join point <em>always</em> represents <strong>a method execution</strong>.</p>
<p><strong>Advice</strong></p>
<p>action taken by an aspect at a particular join point. Different types of advice include “around,” “before” and “after” advice.</p>
<p>Many AOP frameworks, including Spring, model an advice as an <strong><em>interceptor</em></strong>, maintaining <strong>a chain of interceptors</strong> <em>around</em> the join point.</p>
<p><strong>Pointcut</strong>(不太理解，以下都不太理解)</p>
<p>a predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name).</p>
<p>The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the <strong>AspectJ pointcut expression language</strong> by default.</p>
<p><strong>Introduction</strong></p>
<p><strong>Target object</strong></p>
<p><strong>AOP proxy</strong></p>
<p>an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy</p>
<p><strong>Weaving</strong></p>
<p>linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="References-2"><a href="#References-2" class="headerlink" title="References"></a>References</h2><p><a href="https://www.zhihu.com/question/65502802" target="_blank" rel="noopener">https://www.zhihu.com/question/65502802</a></p>
<h2 id="从单体应用到微服务架构"><a href="#从单体应用到微服务架构" class="headerlink" title="从单体应用到微服务架构"></a>从单体应用到微服务架构</h2><h3 id="单体："><a href="#单体：" class="headerlink" title="单体："></a>单体：</h3><ul>
<li>相同业务逻辑的重复代码</li>
<li>数据有时候通过数据库共享，有时通过接口调用传输，接口调用关系复杂。</li>
<li>（比如？）单个应用为了给其他应用提供接口，渐渐地越改越大，包含了很多本来就不属于它的逻辑。应用边界模糊，功能归属混乱。（比如？）</li>
<li>（保障级别？）管理后台在一开始的设计中保障级别较低。加入数据分析和促销管理相关功能后出现性能瓶颈，影响了其他应用。（保障级别？）</li>
<li>所有应用都在一个数据库上操作，数据库出现性能瓶颈。特别是数据分析跑起来的时候，数据库性能急剧下降。</li>
<li>开发、测试、部署、维护愈发困难。即使只改动一个小功能，也需要整个应用一起发布。</li>
</ul>
<h3 id="单一数据库："><a href="#单一数据库：" class="headerlink" title="单一数据库："></a>单一数据库：</h3><ul>
<li>数据库成为性能瓶颈，并且有单点故障的风险。</li>
<li>数据管理趋向混乱。即使一开始有良好的模块化设计，随着时间推移，总会有一个服务直接从数据库取另一个服务的数据的现象。</li>
<li>数据库表结构可能被多个服务依赖，牵一发而动全身，很难调整。</li>
</ul>
<h3 id="数据库拆分"><a href="#数据库拆分" class="headerlink" title="数据库拆分"></a>数据库拆分</h3><h4 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h4><ul>
<li>跨库级联的需求</li>
<li>通过服务查询数据颗粒度的粗细问题等</li>
</ul>
<h3 id="服务拆分的问题"><a href="#服务拆分的问题" class="headerlink" title="服务拆分的问题"></a>服务拆分的问题</h3><ul>
<li>微服务架构整个应用分散成多个服务，<u>定位故障点</u>非常困难。</li>
<li>稳定性下降。服务数量变多导致其中一个服务出现故障的概率增大，并且<u>一个服务故障可能导致整个系统挂掉</u>。事实上，在大访问量的生产场景下，故障总是会出现的。</li>
<li>服务数量非常多，部署、管理的工作量很大。</li>
<li>开发方面：如何保证各个服务在<u>持续开发的情况下</u>仍然保持协同合作。</li>
<li>测试方面：服务拆分后，几乎所有功能都会涉及多个服务。原本<u>单个程序的测试变为服务间调用的测试</u>。测试变得更加复杂。</li>
</ul>
<h3 id="微服务问题的解决"><a href="#微服务问题的解决" class="headerlink" title="微服务问题的解决"></a>微服务问题的解决</h3><ul>
<li>量减少故障发生的概率</li>
<li>降低故障造成的影响</li>
</ul>
<p><img src="C:%5CUsers%5Ccheny%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1584232801104.png" alt="1584232801104"></p>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><h5 id="监控指标："><a href="#监控指标：" class="headerlink" title="监控指标："></a>监控指标：</h5><ul>
<li>Redis缓存一般监控占用内存值、网络流量</li>
<li>数据库监控连接数、磁盘空间</li>
<li>业务服务监控并发数、响应延迟、错误率</li>
</ul>
<h4 id="策略："><a href="#策略：" class="headerlink" title="策略："></a>策略：</h4><ul>
<li>如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差。</li>
<li>一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警。</li>
</ul>
<h4 id="开源组件："><a href="#开源组件：" class="headerlink" title="开源组件："></a>开源组件：</h4><ul>
<li>采用Prometheus作为指标采集器</li>
<li>Grafana配置监控界面和邮件告警</li>
<li>RedisExporter和MySQLExporter</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-ab2479317923472e06d5f3e0b8943944_1440w.jpg" alt="img"></p>
<h3 id="定位问题-链路跟踪"><a href="#定位问题-链路跟踪" class="headerlink" title="定位问题 - 链路跟踪"></a><strong>定位问题 - 链路跟踪</strong></h3><p>在微服务架构下，一个用户的请求往往涉及<u><strong>多个内部服务调用</strong></u>。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少<u>服务调用，及其调用关系</u>。这个叫做链路跟踪。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c1e791200de645b39ed670f9b86109e8_1440w.jpg" alt="img"></p>
<p>从图中可以看到，这是一个用户访问productpage页面的请求。在请求过程中，productpage服务顺序调用了details和reviews服务的接口。而reviews服务在响应过程中又调用了ratings的接口。整个链路跟踪的记录是一棵树：</p>
<p><img src="https://pic2.zhimg.com/80/v2-da001bd5ae83cd8fbcca1dec0db8dc24_1440w.jpg" alt="img"></p>
<p>要实现链路跟踪，每次服务调用会在HTTP的HEADERS中记录至少记录四项数据：</p>
<ul>
<li>traceId：traceId标识一个用户请求的调用链路。具有相同traceId的调用属于同一条链路。</li>
<li>spanId：标识一次服务调用的ID，即链路跟踪的节点ID。</li>
<li>parentId：父节点的spanId。</li>
<li>requestTime &amp; responseTime：请求时间和响应时间。</li>
</ul>
<p>另外，还需要调用日志收集与存储的组件，以及展示链路调用的UI组件。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c1ac0f0772b5ddedafa44636e75b3ded_1440w.jpg" alt="img"></p>
<p>理论依据（谷歌出品）：<br><a href="http://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener">http://bigbully.github.io/Dapper-translation/</a></p>
<h4 id="zipkin（Dapper实现）"><a href="#zipkin（Dapper实现）" class="headerlink" title="zipkin（Dapper实现）"></a>zipkin（Dapper实现）</h4><p>一个独立的分布式追踪系统，客户端存在于应用中（即各服务中），应具备追踪信息生成、采集发送等功能，而服务端应该包含以下基本的三个功能：</p>
<ul>
<li>信息收集：用来收集各服务端采集的信息，并对这些信息进行梳理存储、建立索引。</li>
<li>数据存储：存储追踪数据。</li>
<li>查询服务：提供查询请求链路信息的接口。</li>
</ul>
<p>zipkin 整体结构图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/15/1684f7fabf207ba3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="zipkin 结构图"></p>
<p>zipkin(服务端)包含四个组件，分别是collector、storage、search、web UI。</p>
<ul>
<li>collector 就是信息收集器,作为一个守护进程，它会时刻等待客户端传递过来的追踪数据，对这些数据进行验证、存储以及创建查询需要的索引。</li>
<li>storage  是存储组件。zipkin 默认直接将数据存在内存中，此外支持使用Cassandra、ElasticSearch 和 Mysql。</li>
<li>search 是一个查询进程，它提供了简单的JSON API来供外部调用查询。</li>
<li>web UI 是zipkin的服务端展示平台，主要调用search提供的接口，用图表将链路信息清晰地展示给开发人员。</li>
</ul>
<p>两个概念：</p>
<p>Trace Span</p>
<p>一个请求到达应用后所调用的所有服务所有服务组成的调用链就像一个树结构（如下图），我们<strong>追踪</strong>这个调用<strong>链路</strong>得到的这个树结构可以称之为<strong>Trace</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/15/1684f85bbaffeb7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>在一次Trace中，每个服务的<strong>每一次调用</strong>，就是一个<strong>基本工作单元</strong>，就像上图中的每一个树节点，称之为<strong>span</strong>。每一个span都有一个<strong>id作为唯一标识</strong>，同样每一次Trace都会生成一个<strong>traceId在span中作为追踪标识</strong>，另外再通过一个<strong>parentId标明本次调用的发起者</strong>（就是发起者的span-id）。</p>
<p>当span有了上面三个标识后，就可以很清晰的将多个span进行梳理串联，最终归纳出一条完整的跟踪链路。</p>
<p>此外，span还会有其他数据，比如：名称、节点上下文、时间戳以及K-V结构的tag信息等等。</p>
<p>（Zipkin v1核心注解如“cs”和“sr”已被Span.Kind取代，详情查看<a href="https://zipkin.io/zipkin-api/#/" target="_blank" rel="noopener">zipkin-api</a>，本文会在入门的demo介绍完后对具体的Span数据模型进行说明）。</p>
<h5 id="追踪流程"><a href="#追踪流程" class="headerlink" title="追踪流程"></a>追踪流程</h5><ul>
<li>每个span需要的基本信息何时生成？</li>
<li>哪些信息需要随着服务调用传递给服务提供方？</li>
<li>什么时候发送span至zipkin 服务端？</li>
<li>以何种方式发送span?</li>
</ul>
<p>一个 span 表示一次服务调用，那么追踪器必定是被服务调用发起的动作触发，生成基本信息，同时为了追踪服务提供方对其他服务的调用情况，便需要传递本次追踪链路的traceId和本次调用的span-id。服务提供方完成服务将结果响应给调用方时，需要根据调用发起时记录的时间戳与当前时间戳计算本次服务的持续时间进行记录，至此这次调用的追踪span完成，就可以发送给zipkin服务端了。</p>
<p>但是需要注意的是，发送span给zipkin collector不得影响此次业务结果，其发送成功与否跟业务无关，因此这里需要采用异步的方式发送，防止追踪系统发送延迟与发送失败导致用户系统的延迟与中断。下图就表示了一次http请求调用的追踪流程（基于zipkin官网提供的流程图）： </p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/15/1684f8df1ee94a56?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="一次http请求调用的追踪流程"></p>
<p> 可以看出服务A请求服务B时先被追踪器拦截，记录tag信息、时间戳，同时将追踪标识添加进http header中传递给服务B，在服务B响应后，记录持续时间，最终采取异步的方式发送给zipkin收集器。span从被追踪的服务传送到Zipkin收集器有三种主要的传送方式：http、Kafka以及Scribe（Facebook开源的日志收集系统）。</p>
<h5 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h5><p><a href="https://juejin.im/post/5c3d4df0f265da61307517ad#heading-9" target="_blank" rel="noopener">https://juejin.im/post/5c3d4df0f265da61307517ad#heading-9</a></p>
<h5 id="后续改进"><a href="#后续改进" class="headerlink" title="后续改进"></a>后续改进</h5><p>追踪信息是全量收集还是采样收集，设置什么样的采样频率，异步发送span使用http还是kafka，这些问题都是需要在生产环境中根据实际场景综合考量的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ukyo Chen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ukyo Chen</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
